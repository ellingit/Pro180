

ways out: move, block, capture
King has valid move (can't move into check)
Any friendly piece has valid block or capture move (path from king to attacker)
Move by king or any other piece can't place king in check (general rule...do this first?)
if in check and move doesn't fix it, it isn't a valid move (essentially the same as the rule above seeing as that move would leave the king in check)

move piece on temp board, check for check, invalidate move if in check


effects of moving a piece
everything in the moved piece's path
available moves of any piece that could have used the destination(on or through)
available moves of any piece that can now use the origin

before moving a piece, make a list of affected pieces or locations
could cut down processing time for AI
could simplify check/checkmate checking

--

AI can focus on opening strategies
- opponent AI's will be making less critical decisions near the beginning of the game
- store a bank of opening moves made by chessmasters
	- especially against computers (where the human won)
- favor stalemate over loss
	- how would enemy ai be detecting stalemate? any way to turn that against it?

ALL MOVES METHOD...
private void findAllMoves(){
	for(int i=0; i<board.getBoard().length; i++){
		for(int j=0; j<board.getBoard()[i].length; j++){
			Location currentLocation = new Location(i, j);
			if(board.getPieceAt(currentLocation) != null){
				ArrayList<Location> moves = getDestinations(currentLocation);
				if(moves.size() > 0) allMoves.put(currentLocation, moves);
			}
		}
	}
}
private ArrayList<Location> getDestinations(Location origin){
	ArrayList<Location> moves = new ArrayList<>();
	for(int i=0; i<board.getBoard().length; i++){
		for(int j=0; j<board.getBoard()[i].length; j++){
			Location currentLocation = new Location(i,j);
			if(validMove(origin, currentLocation)) moves.add(currentLocation);
		}
	}
	return moves;
}

ALTERNATIVE isAllowed() METHOD:
//Overloaded method for potential use in verifying checkmate and for AI use
	/*private boolean isAllowed(Piece piece, Location origin, Location destination){
		return piece.validMove((destination.X - origin.X), (destination.Y - origin.Y));
	}*/
	
	
	//TODO: Fix this
//		boolean clear = true;
//		int xD = dest.X - org.X; 
//		int yD = dest.Y - org.Y;
//		if(xD != 0) xD /= Math.abs(xD);
//		if(yD != 0) yD /= Math.abs(yD);
//		Location nextXY;
//		do {
//			nextXY = new Location(org.X + xD, org.Y + yD);
//			clear = isEmpty(nextXY);
//		} while(clear && (nextXY.X != dest.X || nextXY.Y != dest.Y));
//		if(!isEmpty(nextXY)) clear = whiteness != board.getPieceAt(nextXY).getWhiteness();
//		return clear;

attack tactics <----
Fork
Discovered Attack
Skewer

looking for patterns instead of memorizing moves

Queen - 9
Rook - 5
Bishop - 3
Knight - 3
Pawn - 1

never move a pawn unless it helps develop a power piece

3 parts to a game

opening, midgame, endgame

always seek favorable endgame